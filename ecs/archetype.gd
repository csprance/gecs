## Archetype
##
## Represents a unique combination of component types in the ECS framework.
## Entities with the exact same set of components share an archetype.
##
## Archetypes enable high-performance queries by grouping entities with identical
## component structures together in flat arrays, providing excellent cache locality
## and eliminating the need for set intersections during queries.
##
## [b]Key Concepts:[/b]
## - [b]Signature:[/b] Hash of all component types (determines archetype identity)
## - [b]Entities:[/b] Flat array of entities with this exact component combination
## - [b]Edges:[/b] Fast lookup for when components are added/removed (future optimization)
##
## [b]Example:[/b]
## [codeblock]
## # Archetype for entities with Position + Velocity
## var archetype = Archetype.new(12345, ["Position", "Velocity"])
## archetype.add_entity(player)
## archetype.add_entity(enemy)
## # Now both entities are stored contiguously for fast iteration
## [/codeblock]
##
## [b]Performance:[/b]
## - Add entity: O(1) amortized (array append)
## - Remove entity: O(1) (swap-remove with index tracking)
## - Query match: O(1) (check if archetype signature matches query)
## - Iterate entities: O(n) with excellent cache locality
class_name Archetype
extends RefCounted

## Unique hash identifying this component combination
## Generated by World._generate_query_cache_key() from sorted component types
var signature: int = 0

## Sorted array of component resource paths (e.g., ["res://c_position.gd", "res://c_velocity.gd"])
## Used for debugging and archetype matching logic
var component_types: Array = []

## Flat array of entities with this exact component combination
## Provides excellent cache locality when iterating in systems
var entities: Array[Entity] = []

## Fast lookup: Entity -> index in entities array
## Enables O(1) entity removal using swap-remove technique
var entity_to_index: Dictionary = {}  # Entity -> int

## OPTIMIZATION: Structure of Arrays (SoA) column storage for cache-friendly iteration
## Maps component_path -> Array of component instances
## Enables Flecs-style direct array iteration without dictionary lookups
## Example: columns["res://c_velocity.gd"] = [vel1, vel2, vel3, ...]
var columns: Dictionary = {}  # String (component_path) -> Array of components

## Is this archetype for enabled entities only? (null = mixed, true = enabled, false = disabled)
## Used to optimize queries with enabled/disabled filters
var enabled_filter: Variant = null

## Archetype edges for fast component add/remove (future optimization)
## Maps: component_path -> Archetype (the archetype you get by adding/removing that component)
var add_edges: Dictionary = {}  # String -> Archetype
var remove_edges: Dictionary = {}  # String -> Archetype


## Initialize archetype with signature and component types
func _init(p_signature: int, p_component_types: Array, p_enabled_filter: Variant = null):
	signature = p_signature
	component_types = p_component_types.duplicate()
	component_types.sort()  # Ensure sorted for consistent matching
	enabled_filter = p_enabled_filter

	# Initialize column arrays for each component type
	for comp_type in component_types:
		columns[comp_type] = []


## Add an entity to this archetype
## Uses O(1) append and tracks index for fast removal
## OPTIMIZATION: Also populates column arrays for cache-friendly iteration
func add_entity(entity: Entity) -> void:
	var index = entities.size()
	entities.append(entity)
	entity_to_index[entity] = index

	# OPTIMIZATION: Populate column arrays from entity.components
	for comp_path in component_types:
		if entity.components.has(comp_path):
			columns[comp_path].append(entity.components[comp_path])
		else:
			# Entity doesn't have this component yet (might be mid-initialization)
			# Push null placeholder, will be fixed when component is added
			columns[comp_path].append(null)


## Remove an entity from this archetype using swap-remove
## O(1) operation: swaps with last entity and pops
## OPTIMIZATION: Also maintains column arrays in sync
func remove_entity(entity: Entity) -> bool:
	if not entity_to_index.has(entity):
		return false

	var index = entity_to_index[entity]
	var last_index = entities.size() - 1

	# Swap with last element in entities array
	if index != last_index:
		var last_entity = entities[last_index]
		entities[index] = last_entity
		entity_to_index[last_entity] = index

		# OPTIMIZATION: Swap in column arrays too (maintain same ordering)
		for comp_path in component_types:
			columns[comp_path][index] = columns[comp_path][last_index]

	# Remove last element from entities
	entities.pop_back()
	entity_to_index.erase(entity)

	# OPTIMIZATION: Remove last element from all columns
	for comp_path in component_types:
		columns[comp_path].pop_back()

	return true


## Check if this archetype has a specific entity
func has_entity(entity: Entity) -> bool:
	return entity_to_index.has(entity)


## Get entity count in this archetype
func size() -> int:
	return entities.size()


## Check if archetype is empty
func is_empty() -> bool:
	return entities.is_empty()


## Clear all entities from this archetype
func clear() -> void:
	entities.clear()
	entity_to_index.clear()

	# OPTIMIZATION: Clear column arrays
	for comp_path in component_types:
		columns[comp_path].clear()


## Check if this archetype matches a query with all/any/exclude components
## [param all_comp_types] Component paths that must all be present
## [param any_comp_types] Component paths where at least one must be present
## [param exclude_comp_types] Component paths that must not be present
func matches_query(all_comp_types: Array, any_comp_types: Array, exclude_comp_types: Array) -> bool:
	# Check all_components: must have ALL of these
	for comp_type in all_comp_types:
		if not component_types.has(comp_type):
			return false

	# Check any_components: must have AT LEAST ONE of these
	if not any_comp_types.is_empty():
		var has_any = false
		for comp_type in any_comp_types:
			if component_types.has(comp_type):
				has_any = true
				break
		if not has_any:
			return false

	# Check exclude_components: must have NONE of these
	for comp_type in exclude_comp_types:
		if component_types.has(comp_type):
			return false

	return true


## Get a debug-friendly string representation
func _to_string() -> String:
	var comp_names = []
	for comp_type in component_types:
		# Extract just the class name from the path
		var parts = comp_type.split("/")
		var filename = parts[parts.size() - 1].replace(".gd", "")
		comp_names.append(filename)

	return "Archetype[sig=%d, comps=%s, entities=%d]" % [
		signature,
		str(comp_names),
		entities.size()
	]


## Set up an edge to another archetype when a component is added
## Enables O(1) archetype transitions when components change
func set_add_edge(component_path: String, target_archetype: Archetype) -> void:
	add_edges[component_path] = target_archetype


## Set up an edge to another archetype when a component is removed
## Enables O(1) archetype transitions when components change
func set_remove_edge(component_path: String, target_archetype: Archetype) -> void:
	remove_edges[component_path] = target_archetype


## Get the target archetype when adding a component (if edge exists)
func get_add_edge(component_path: String) -> Archetype:
	return add_edges.get(component_path, null)


## Get the target archetype when removing a component (if edge exists)
func get_remove_edge(component_path: String) -> Archetype:
	return remove_edges.get(component_path, null)


## OPTIMIZATION: Get component column array for cache-friendly iteration
## Enables Flecs-style direct array access instead of dictionary lookups per entity
## [param component_path] The resource path of the component type (e.g., C_Velocity.resource_path)
## [returns] Array of component instances in entity index order, or empty array if not found
##
## Example:
## [codeblock]
## var velocities = archetype.get_column(C_Velocity.resource_path)
## for i in range(velocities.size()):
##     var velocity = velocities[i]
##     var entity = archetype.entities[i]
##     # Process with cache-friendly sequential access
## [/codeblock]
func get_column(component_path: String) -> Array:
	return columns.get(component_path, [])
